# Bridges Watcher

Этот проект автоматически проверяет почтовый ящик, парсит входящие письма по настраиваемым правилам и отправляет оформленные уведомления в Slack. Документ ниже объединяет информацию о развёртывании репозитория, настройке окружения и подробном описании формата `parser_config.csv`.

## Структура проекта

```text
C:\Folder\
    ├─ x_core.py          # основной файл скрипта
    ├─ .env               # переменные окружения для IMAP и Slack (создать вручную)
    ├─ parser_config.csv  # конфигурация правил парсинга писем
    ├─ run.bat            # сценарий для ручного/планового запуска
    ├─ run_hidden.vbs     # необязательный запуск без консоли
    ├─ xcore.log          # журнал работы (создаётся автоматически)
    └─ xcore_uid.pkl      # кеш обработанных UID писем (создаётся автоматически)
```

## Установка и подготовка окружения

### 1. Клонирование и подготовка папки
1. Создайте рабочий каталог, например `C:\Folder`, и поместите туда файлы из репозитория.
2. Убедитесь, что установлен Python 3.10 или новее.

### 2. Установка зависимостей
1. Найдите путь к `python.exe` (команда `where python` в CMD).
2. Установите требуемые пакеты:
   ```cmd
   pip install boto3 requests beautifulsoup4 python-dotenv
   ```
   Если Python не добавлен в `PATH`, вызывайте `pip` через полный путь:
   ```cmd
   C:\Users\User\AppData\Local\Programs\Python\Python313\python.exe -m pip install boto3 requests beautifulsoup4 python-dotenv
   ```
3. При отсутствии `pip` скачайте `get-pip.py` с https://bootstrap.pypa.io/get-pip.py и выполните через `python.exe`.

### 3. Файл `.env`
Создайте `.env` рядом с `x_core.py` и заполните переменные окружения:
```env
IMAP_HOST=imap.example.com
IMAP_USER=user@example.com
IMAP_PASS=password123
SLACK_URL=https://hooks.slack.com/services/XXX/YYY/ZZZ
SLACK_BOT_TOKEN=xoxb-1234567890-...
SLACK_CHANNEL=C0123456789
UID_OBJECT_KEY=uid.pkl
CHECK_SEC=10
DEBUG_EMAIL=0
```
* `IMAP_*` — параметры почтового ящика.
* `SLACK_URL` — URL входящего вебхука Slack.
* `SLACK_BOT_TOKEN` и `SLACK_CHANNEL` — необязательный fallback через Slack Web API. Если вебхук недоступен, скрипт вызовет `chat.postMessage` от имени бота.
* `CHECK_SEC` — пауза между итерациями цикла (в секундах).
* `DEBUG_EMAIL=1` включает подробные отладочные записи о каждой обработке письма.
* Значения из `.env` имеют приоритет над уже установленными переменными окружения процесса.
  Источник считанных значений (`.env`, `env` или `missing`) выводится в логах.

### 4. Скрипт запуска (`run.bat`)
```bat
@echo off
cd /d "C:\Folder"
for /f "delims=" %%a in (.env) do set %%a
"C:\Users\User\AppData\Local\Programs\Python\Python313\python.exe" x_core.py
```
Запускайте `run.bat` вручную или через планировщик. Для фонового режима можно использовать `run_hidden.vbs`, который вызывает `run.bat` без консольного окна.

### 5. Планировщик задач Windows
1. Откройте планировщик (`Win + R` → `taskschd.msc`).
2. Создайте задачу («Create Task») и настройте триггеры/условия.
3. В действиях укажите запуск `C:\Folder\run.bat`.
4. Сохраните задачу и протестируйте запуск вручную.

## Запуск и отладка

### Базовый запуск
Дважды кликните `run.bat` или выполните его из командной строки. Скрипт будет работать циклически, проверяя новые письма и отправляя сообщения в Slack.

### Отладочные ключи
Для одноразовых проверок доступны опции командной строки:

```cmd
python x_core.py --slack-info
```
— выводит обезличенную информацию о вебхуке (хост, team/channel, длина токена) и при наличии fallback-а показывает канал и отпечаток токена бота. Полезно для проверки корректности `SLACK_URL` и `SLACK_BOT_TOKEN`/`SLACK_CHANNEL`.

```cmd
python x_core.py --check-slack "Тестовое сообщение"
```
— отправляет одно сообщение в Slack и завершает работу. Если текст не указан, используется шаблонное сообщение `Bridges Watcher Slack connectivity test`.

```cmd
python x_core.py --run-once
```
— выполняет один цикл проверки почты без перехода в бесконечный режим. Аргументы можно комбинировать.

### Логи и полезные советы
* Основной лог — `xcore.log`. На уровне `DEBUG` выводятся подробности о Slack‑запросах и применённых правилах.
* Файл `xcore_uid.pkl` хранит UID уже обработанных писем, чтобы не отправлять повторно.
* При `404` от Slack перепроверьте актуальность `SLACK_URL` или перевыпустите вебхук.

## Настройка `parser_config.csv`

Файл `parser_config.csv` определяет правила разбора писем. Каждая строка описывает один шаблон, который:
1. Отфильтровывает письма по отправителю/теме (опционально).
2. Выполняет поиск совпадений в теле письма через регулярное выражение.
3. Формирует словарь полей и подставляет их в шаблон сообщения для Slack.

### Формат CSV
* Разделитель может быть `,`, `;` или табуляция. Используйте двойные кавычки для сложных значений (`pattern`, `field_map`, `slack_format`).
* Поле `field_map` должно содержать валидный JSON-объект.
* Последовательность `\n` в текстовых полях превращается в перевод строки в конечном сообщении.

### Обязательные поля
1. **name** — уникальное имя правила, отображается в логах.
2. **pattern** — RegEx с именованными группами (`?P<имя>...`). Применяется ко всему очищенному телу письма.
3. **field_map** — JSON-словарь с Python-выражениями. Выражения получают доступ к `groupdict` и могут формировать дополнительные поля. Выполняются безопасно в ограниченном пространстве.
4. **slack_format** — шаблон вывода в Slack. Доступны все поля из RegEx и `field_map`.

### Необязательные поля
5. **note** — текст, добавляемый в конец сообщения Slack с префиксом `*ACTIONS:*`.
6. **exclude_fields** — перечень полей (через запятую) для исключения перед форматированием. Будьте внимательны: если исключить поле, используемое в `slack_format`, возникнет `KeyError`.
7. **email_address** — фильтр по адресу отправителя (подстрока). Если не указан, правило применимо ко всем письмам.
8. **email_theme** — RegEx-фильтр по теме письма.
9. **strip_pattern** — RegEx для удаления лишних блоков до поиска `pattern`. Аналог глобального «удалить всё, что попадает под шаблон» (включая из `rest`).
10. **truncate_pattern** — RegEx, который ищется уже внутри поля `rest`; всё, что идёт после совпадения, отбрасывается.

### Дополнительные подсказки
* Если в письме несколько участков совпадают с `pattern`, скрипт агрегирует их: значения `rest` объединяются через перенос строки.
* В `slack_format` разрешены элементы Slack mrkdwn (`*жирный*`, блоки ``` и т. д.).
* Поля из `field_map` можно повторно использовать для вычислений. Пример: преобразовать `priority: high` в `HIGH PRIORITY`.
* При необходимости добавляйте собственные вспомогательные функции в `field_map`, если они доступны в ограниченном пространстве (например, `kv_blocks` для разбора пар `ключ: значение`).

### Пример строки в CSV
```csv
xcore_log,"(?P<ts>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3})\s+\[(?P<lvl>[A-Z]+)\s*\]\s+(?P<comp>[^:]+):\s*(?P<rest>.*?)(?=(\d{4}-\d{2}-\d{2} \d{2}|\Z))","{""stat"": ""rest.split(':')[1].strip() if ':' in rest else ''""}","*CATEGORY:* XCORE\n*TIMESTAMP:* {ts}\n*LEVEL:* {lvl}\n*STATUS:* {stat}\n*EVENT_TEXT:*\n```\n{rest}\n```",,,,,"this\s*alert\s*has\s*been\s*automatically\s*generated[\s\S]*","\d{4}-\d{2}-\d{2} \d{2}"
```

### Пример итогового сообщения в Slack
```text
> *CATEGORY:* XCORE
> *TIMESTAMP:* 2024-07-10 12:34:56.789
> *LEVEL:* ERROR
> *STATUS:* critical system timeout
> *EVENT_TEXT:*
> ```
> Job failed: critical system timeout
> ```
> *ACTIONS:* Дополнительные инструкции
```

## Автоматически создаваемые файлы
* `xcore.log` — журнал работы. При `DEBUG_EMAIL=1` фиксируется информация о каждом письме (SENT/SKIPPED, применённые правила и т. д.).
* `xcore_uid.pkl` — сериализованный набор UID обработанных писем, чтобы избежать повторных отправок.

## Тестирование
Для проверки синтаксиса можно запустить:
```cmd
python -m compileall x_core.py
```
Команда убедится, что скрипт компилируется без синтаксических ошибок.

## Частые проблемы
* **Slack возвращает 404.** Вебхук удалён или ссылка указана с ошибкой. Сгенерируйте новый URL, обновите `.env` и перезапустите скрипт. Если настроены `SLACK_BOT_TOKEN`+`SLACK_CHANNEL`, уведомление отправится через API даже при ошибке вебхука.
* **Правило не срабатывает.** Проверьте фильтры `email_address`/`email_theme` и убедитесь, что `pattern` действительно находит совпадение (удобно временно включить `DEBUG_EMAIL=1`).
* **Ошибки в `field_map`.** Убедитесь, что JSON корректен и выражения не обращаются к исключённым полям.

## Обратная связь
При возникновении вопросов или необходимости добавить новые правила обновляйте `parser_config.csv` и, при необходимости, дополняйте этот README новыми примерами.
